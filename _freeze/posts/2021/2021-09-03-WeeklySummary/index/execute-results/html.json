{
  "hash": "b0f5a84aa3da4c76b7e080e13acf35d8",
  "result": {
    "markdown": "---\ntitle: 一周小结\nauthor: 桑峰\ndate: 2021-09-03\nslug: blog\noutput: html_document\ncategories:\n  - Summary\ntags:\n  - Parallel\n  - Python\n  - R\n  - annot\n  - ggplot2\n---\n\n\n## Python并行处理\n\nPython 中的concurrent包提供了对于并行运行的接口，包括进程级并行和线程级并行。下面是一个例子。\n\n```python\nfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor\n\ndef func(a, b):\n    return a*b\n\nif __name__ == '__main__':\n    n_core = 4\n    nums = 10000\n    b = 2\n\n    res = [0 for _ in range(nums)]\n    with ProcessPoolExecutor(n_core) as pool:\n        futures = {pool.submit(func, i, b): i for i in range(1, nums)}\n        for f in futures:\n            res[futures[f]] = f.result()\n    \n    res = [0 for _ in range(nums)]\n    with ThreadPoolExecutor(n_core) as pool:\n        futures = {pool.submit(func, i, b): i for i in range(1, nums)}\n        for f in futures:\n            res[futures[f]] = f.result()\n```\n\n在并行处理时，写明 ***python if __name__ == '__main__'*** 以声明主进程。\n\n进程级并行时，各个并行进程之间独享计算资源（尤其是内存）。对于这个例子，就是会为每个进程拷贝一个 **b** 。这样的好处是进程之间基本不会相互影响，对于I/O型任务的效率提升较大；而缺点是会增加内存的消耗。\n\n对于线程级并行，并行线程之间可以共享变量，因此相比起进程级别的并行，消耗的内存会更少。\n\n> 上面的线程和进程相关的描述是笔者久远的记忆加上自己的理解，可能不准确，但代码可用。\n\n**futures[f]** 会返回 **{pool.submit(func, i, b): i for i in range(1, nums)}** 里面的 **i**。\n\n## R并行处理\n\nR 里面的 **snowfall** 包提供了并行的接口。\n\n```r\nlibrary(snowfall)\n\nparallel <- function(x, y) {\n  sfCat(print(x))\n  return(x * y)\n}\n\nb <- 2\nsfInit(parallel = TRUE, cpus = 4, slaveOutfile = 'demo.log')\nsfLibrary(snowfall)\nsfExport('b')\nres <- sfSapply(1:5, parallel, b)\nsfStop()\n```\n\n**sfInit** 用于设置基础环境，其中 **slaveOutfile** 用来重定向并行中的输出信息，方便检测进度。\n\n**sfLibrary** 函数导入并行函数需要的包。\n\n**sfExport** 函数将外部变量和函数导入并行函数。\n\n**sfSapply** 类似 R 中其他的***apply**函数族，返回值类似。\n\n**sfCat** 函数将并行过程中的信息输出。如果在 **slaveOutfile** 中设置了，输出信息将保存到相应的文件中。\n\n## annot文件\n\n**FreeSurfer** 中的函数可以将 **.annot** 文件转换为 **.gii** 文件，命令如下。\n\n```bash\nmris_convert --annot lh.aparc.annot lh.white lh.aparc.gii\n```\n\n## ggplot2中自定义字体\n\n```r\nlibrary(showtext)\n\nfont.add('calibri', 'xxx.ttf')\nshowtext.auto()\nggplot() ...\n```\n\n**showtext** 包可以载入外部字体。利用 **font.add** 函数，载入字体文件。**showtext.auto** 函数可以在后面的绘图中自动使用载入的字体。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}